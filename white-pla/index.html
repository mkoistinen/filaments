<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>White FDM Filament Color Comparison</title>
    <style>
        :root {
            --bg-color: #ffffff;
            --text-color: #24292e;
            --border-color: #d0d7de;
            --table-header-bg: #f6f8fa;
            --table-header-hover: #e8ecef;
            --button-bg: #fff;
            --button-hover: #f0f0f0;
            --button-active-bg: #0969da;
            --button-active-color: #fff;
            --heading-border: #eaecef;
            --swatch-border: #999;
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg-color: #0d1117;
                --text-color: #c9d1d9;
                --border-color: #30363d;
                --table-header-bg: #161b22;
                --table-header-hover: #1f2428;
                --button-bg: #21262d;
                --button-hover: #30363d;
                --button-active-bg: #1f6feb;
                --button-active-color: #fff;
                --heading-border: #21262d;
                --swatch-border: #6e7681;
            }
        }

        body.light-mode {
            --bg-color: #ffffff;
            --text-color: #24292e;
            --border-color: #d0d7de;
            --table-header-bg: #f6f8fa;
            --table-header-hover: #e8ecef;
            --button-bg: #fff;
            --button-hover: #f0f0f0;
            --button-active-bg: #0969da;
            --button-active-color: #fff;
            --heading-border: #eaecef;
            --swatch-border: #999;
        }

        body.dark-mode {
            --bg-color: #0d1117;
            --text-color: #c9d1d9;
            --border-color: #30363d;
            --table-header-bg: #161b22;
            --table-header-hover: #1f2428;
            --button-bg: #21262d;
            --button-hover: #30363d;
            --button-active-bg: #1f6feb;
            --button-active-color: #fff;
            --heading-border: #21262d;
            --swatch-border: #6e7681;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif;
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
            line-height: 1.6;
            background-color: var(--bg-color);
            color: var(--text-color);
            transition: background-color 0.3s, color 0.3s;
        }
        h1 {
            border-bottom: 1px solid var(--heading-border);
            padding-bottom: 0.3em;
            margin-top: 24px;
            margin-bottom: 16px;
        }
        h2 {
            border-bottom: 1px solid var(--heading-border);
            padding-bottom: 0.3em;
            margin-top: 24px;
            margin-bottom: 16px;
        }
        p {
            margin-bottom: 16px;
        }
        table {
            border-collapse: collapse;
            width: 100%;
            margin-bottom: 16px;
        }
        th {
            background-color: var(--table-header-bg);
            font-weight: 600;
            padding: 6px 13px;
            border: 1px solid var(--border-color);
            cursor: pointer;
            user-select: none;
        }
        th:hover {
            background-color: var(--table-header-hover);
        }
        th.sorted-asc::after {
            content: ' â†‘';
            opacity: 1;
        }
        th.sorted-desc::after {
            content: ' â†“';
            opacity: 1;
        }
        td {
            padding: 6px 13px;
            border: 1px solid var(--border-color);
            transition: background-color 0.2s ease;
        }
        td:nth-child(4) {
            text-align: right;
        }
        tbody tr {
            cursor: pointer;
        }
        .color-mode-switcher {
            display: flex;
            gap: 5px;
            margin-bottom: 16px;
            align-items: center;
        }
        .color-mode-btn {
            padding: 6px 12px;
            background: var(--button-bg);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.95em;
            transition: all 0.2s;
            color: var(--text-color);
        }
        .color-mode-btn:hover {
            background: var(--button-hover);
        }
        .color-mode-btn.active {
            background: var(--button-active-bg);
            color: var(--button-active-color);
            border-color: var(--button-active-bg);
        }
        .color-swatch {
            display: inline-block;
            width: 24px;
            height: 24px;
            border: 0px solid var(--swatch-border);
            border-radius: 3px;
            vertical-align: middle;
            margin-right: 8px;
        }
        .theme-toggle {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 8px 16px;
            background: var(--button-bg);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9em;
            transition: all 0.2s;
            color: var(--text-color);
        }
        .theme-toggle:hover {
            background: var(--button-hover);
        }

        /* Responsive design for mobile */
        @media screen and (max-width: 768px) {
            body {
                padding: 10px;
                font-size: 14px;
            }

            h1 {
                font-size: 1.5em;
                margin-top: 16px;
            }

            h2 {
                font-size: 1.2em;
            }

            .theme-toggle {
                top: 10px;
                right: 10px;
                padding: 6px 12px;
                font-size: 0.85em;
            }

            .color-mode-switcher {
                flex-wrap: wrap;
                gap: 4px;
            }

            .color-mode-btn {
                padding: 5px 10px;
                font-size: 0.85em;
            }

            table {
                font-size: 0.9em;
            }

            th, td {
                padding: 4px 8px;
            }

            .color-swatch {
                width: 20px;
                height: 20px;
                margin-right: 6px;
            }

            /* Make table scrollable horizontally on very small screens */
            .table-container {
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
            }
        }

        @media screen and (max-width: 480px) {
            body {
                padding: 5px;
                font-size: 13px;
            }

            h1 {
                font-size: 1.3em;
            }

            .color-mode-btn {
                font-size: 0.8em;
                padding: 4px 8px;
            }

            table {
                font-size: 0.85em;
            }

            th, td {
                padding: 3px 6px;
            }

            .color-swatch {
                width: 18px;
                height: 18px;
                margin-right: 4px;
            }
        }
    </style>
</head>
<body>
    <button class="theme-toggle" onclick="toggleTheme()">
        <span id="theme-icon">ðŸŒ™</span> <span id="theme-text">Dark</span>
    </button>

    <h1>White FDM Filament Color Comparison</h1>

    <p>
        "White" is a very relative term, especially in the Thermoplastics
        space. I'm on a quest for the best looking white for my application.
        This webpage presents my own findings for all the white filaments I
        come across.
    </p>
    <p>
        I previously posted my results on a <a href="https://www.reddit.com/r/3Dprinting/comments/10tv174/quality_white_pla_filament/">Reddit post</a> in the 3Dprinting
        sub-reddit. However, at some point, I was unable to update the post with
        new filaments due to age or perhaps post-length, so, this page was born.
    </p>
    <p>
        All the filaments shown in the table below were printed into samples on
        my Prusa MK4S or CORE One using the same generic PLA filament profile.
        Colors are measured using my specific Pico Colorimeter in the same
        environment with the same ambient lighting and roughly the same
        temperature. The measurements are the average of 3 samples take from
        surfaces printed along the different Cartesian planes (XY, XZ, YZ). The
        color is stored as Lab format on this webpage and all other color
        formats are derived from that value.
    </p>
    <p>
        The recorded values are different than previously presented on the
        Reddit post. The primary reason for this the my new practice of
        averaging 3 measurements for each of the Cartesian planes of printing.
        This was most notable for the Silk-effect filaments, which are likely
        engineered to reflect different color light in different directions.
        Interestingly, all of the filaments had some degree of visible variance
        when measured this way.
    </p>

    <h3>Color Swatches</h3>
    <p>
        The color swatches use an advanced Floyd-Steinberg dithering algorithm
        for achieving sub-pixel accuracy when the true color falls between
        discrete RGB values (e.g., RGB 245.7 instead of 246). Dithered swatches
        use a carefully calculated pattern of pixels to create a more
        accurate perceptual representation than is possible with sRGB
        colors alone.
    </p>
    <p>
        Additionally, if you roll over or touch a specific filament, the
        background color of all filaments in the Color column will reflect the
        indicated filament. This makes it easy to see the difference of the
        indicated filament color versus the remaining ones. Try it!
    </p>
    <p>
        Despite all these efforts to improve the accuracy, the color swatches
        are still only <strong>rough approximations</strong> of the sampled
        colors and should be treated as such. They are probably most
        visually accurate when the page is viewed in dark mode, but displaying
        a color in an HTML color swatch or photograph on an arbitrary display
        cannot truly represent how these 3D printed samples appear when
        observed in person under ideal lighting conditions. Regardless, I can
        attest that the <em>relative</em> differences between colors are
        represented by these HTML color swatches.
    </p>

    <h2>The Filament Table</h2>
    <p>
        The are initially organized by "lightness" (L value in Lab) from
        highest to lowest but you can click a column header to sort differently.
    </p>

    <div class="color-mode-switcher">
        <strong>Color Format:</strong>
        <button class="color-mode-btn active" data-mode="lab">LAB</button>
        <button class="color-mode-btn" data-mode="rgb">RGB</button>
        <button class="color-mode-btn" data-mode="hsv">HSV</button>
        <button class="color-mode-btn" data-mode="hex">Hex</button>
        <strong style="padding-left: 2em;">Sort by:</strong>
        <button class="color-mode-btn" data-sort="lightness">Lightness â†“</button>
        <button class="color-mode-btn" data-sort="warmth">Tint Warmth â†‘</button>
        <button class="color-mode-btn" data-sort="strength">Tint Strength â†‘</button>
    </div>

    <div class="table-container">
        <table id="filamentTable">
            <thead>
                <tr>
                    <th data-sort="brand">Brand</th>
                    <th data-sort="polymer">Color/Polymer</th>
                    <th data-sort="color">Color</th>
                    <th data-sort="date">Date Added</th>
                    <!-- <th data-sort="cost">USD/Kg</th> -->
                </tr>
        </thead>
        <tbody>
           <tr data-lab="94.2, -2.2, -0.1">
                <td>Sunlu</td>
                <td>While PLA</td>
                <td class="color-cell"></td>
                <td data-date="20251117">17-Nov-2025</td>
                <!-- <td>16.99</td> -->
            </tr>
            <tr data-lab="92.6, -1.8, -0.6">
                <td>Push Plastic</td>
                <td>White PLA</td>
                <td class="color-cell"></td>
                <td data-date="20251117">17-Nov-2025</td>
                <!-- <td>19.99</td> -->
            </tr>
            <tr data-lab="92.4, -2.1, -2.2">
                <td>eSun</td>
                <td>Basic PLA - White</td>
                <td class="color-cell"></td>
                <td data-date="20251117">17-Nov-2025</td>
                <!-- <td>11.99</td> -->
            </tr>
            <tr data-lab="92.2, -2.3, -0.4">
                <td>Hatchbox</td>
                <td>White PLA</td>
                <td class="color-cell"></td>
                <td data-date="20251117">17-Nov-2025</td>
                <!-- <td>28.00</td> -->
            </tr>
            <tr data-lab="91.1, -2.0, -0.4">
                <td>ProtoPasta</td>
                <td>Opaque White HTPLA</td>
                <td class="color-cell"></td>
                <td data-date="20251117">17-Nov-2025</td>
                <!-- <td>99.99</td> -->
            </tr>
            <tr data-lab="90.5, -2.3, -1.2">
                <td>Overture</td>
                <td>White Pro PLA</td>
                <td class="color-cell"></td>
                <td data-date="20251117">17-Nov-2025</td>
                <!-- <td>15.65</td> -->
            </tr>
            <tr data-lab="90.4, -1.0, 0.1">
                <td>Overture</td>
                <td>White Matte PLA</td>
                <td class="color-cell"></td>
                <td data-date="20251117">17-Nov-2025</td>
                <!-- <td>15.12</td> -->
            </tr>
            <tr data-lab="89.7, -1.9, -3.6">
                <td>eSun</td>
                <td>Cool White PLA</td>
                <td class="color-cell"></td>
                <td data-date="20251117">17-Nov-2025</td>
                <!-- <td>22.99</td> -->
            </tr>
            <tr data-lab="89.3, 2.8, -7.8">
                <td>Bblife</td>
                <td>Silk White PLA</td>
                <td class="color-cell"></td>
                <td data-date="20251117">17-Nov-2025</td>
                <!-- <td>21.59</td> -->
            </tr>
            <tr data-lab="89.2, -0.3, -5.0">
                <td>Cryddle</td>
                <td>White PLA</td>
                <td class="color-cell"></td>
                <td data-date="20251119">19-Nov-2025</td>
                <!-- <td>9.99</td> -->
            </tr>
            <tr data-lab="87.6, -0.6, -1.7">
                <td>Soleyin</td>
                <td>Ultra PLA White</td>
                <td class="color-cell"></td>
                <td data-date="20251119">19-Nov-2025</td>
                <!-- <td>12.99</td> -->
            </tr>
            <tr data-lab="87.3, 3.2, -6.5">
                <td>Mika 3D</td>
                <td>Silk White PLA</td>
                <td class="color-cell"></td>
                <td data-date="20251117">17-Nov-2025</td>
                <!-- <td>17.09</td> -->
            </tr>
            <tr data-lab="85.9, 0.1, -0.8">
                <td>Elegoo</td>
                <td>White PLA Plus</td>
                <td class="color-cell"></td>
                <td data-date="20251117">17-Nov-2025</td>
                <!-- <td>14.99</td> -->
            </tr>
            <tr data-lab="85.7, -0.5, -0.8">
                <td>Deeplee</td>
                <td>White PLA</td>
                <td class="color-cell"></td>
                <td data-date="20251119">19-Nov-2025</td>
                <!-- <td>11.99</td> -->
            </tr>
            <tr data-lab="85.3, -1.4, -1.9">
                <td>Mika 3D</td>
                <td>White PLA</td>
                <td class="color-cell"></td>
                <td data-date="20251117">17-Nov-2025</td>
                <!-- <td>17.26</td> -->
            </tr>
            <tr data-lab="83.4, -1.2, -1.7">
                <td>Prusament</td>
                <td>Pristine White PLA</td>
                <td class="color-cell"></td>
                <td data-date="20251117">17-Nov-2025</td>
                <!-- <td>26.99</td> -->
            </tr>
            <tr data-lab="83.2, 0.2, -5.1">
                <td>3D Solutech</td>
                <td>Real White Premium PLA</td>
                <td class="color-cell"></td>
                <td data-date="20251117">17-Nov-2025</td>
                <!-- <td>19.99</td> -->
            </tr>
        </tbody>
    </table>
    </div>
    <script>
        // Theme management
        function getSystemTheme() {
            return window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
        }

        function getStoredTheme() {
            return localStorage.getItem('theme');
        }

        function setTheme(theme) {
            if (theme === 'auto') {
                const systemTheme = getSystemTheme();
                document.body.className = systemTheme === 'dark' ? 'dark-mode' : 'light-mode';
                updateThemeButton('auto', systemTheme);
            } else {
                document.body.className = theme === 'dark' ? 'dark-mode' : 'light-mode';
                updateThemeButton(theme, theme);
            }
            localStorage.setItem('theme', theme);
        }

        function updateThemeButton(storedTheme, actualTheme) {
            const icon = document.getElementById('theme-icon');
            const text = document.getElementById('theme-text');

            if (storedTheme === 'auto') {
                icon.textContent = 'ðŸ”„';
                text.textContent = `Auto (${actualTheme === 'dark' ? 'Dark' : 'Light'})`;
            } else if (actualTheme === 'dark') {
                icon.textContent = 'â˜€ï¸';
                text.textContent = 'Switch to Light';
            } else {
                icon.textContent = 'ðŸŒ™';
                text.textContent = 'Switch to Dark';
            }
        }        function toggleTheme() {
            const currentStored = getStoredTheme() || 'auto';

            if (currentStored === 'auto') {
                setTheme('light');
            } else if (currentStored === 'light') {
                setTheme('dark');
            } else {
                setTheme('auto');
            }
        }

        // Initialize theme on page load
        const storedTheme = getStoredTheme() || 'auto';
        setTheme(storedTheme);

        // Listen for system theme changes when in auto mode
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', (e) => {
            if (getStoredTheme() === 'auto' || !getStoredTheme()) {
                setTheme('auto');
            }
        });

        let currentColorMode = 'lab';
        let currentSort = { column: null, direction: 'asc' };

        // Utility functions
        function parseLAB(labString) {
            const parts = labString.split(',').map(s => parseFloat(s.trim()));
            return { L: parts[0], a: parts[1], b: parts[2] };
        }

        // LAB to XYZ conversion (D65 illuminant)
        function labToXYZ(L, a, b) {
            let y = (L + 16) / 116;
            let x = a / 500 + y;
            let z = y - b / 200;

            const fx = x > 0.206897 ? Math.pow(x, 3) : (x - 16/116) / 7.787;
            const fy = y > 0.206897 ? Math.pow(y, 3) : (y - 16/116) / 7.787;
            const fz = z > 0.206897 ? Math.pow(z, 3) : (z - 16/116) / 7.787;

            // D65 white point
            const X = fx * 95.047;
            const Y = fy * 100.000;
            const Z = fz * 108.883;

            return { X, Y, Z };
        }

        // XYZ to RGB conversion (sRGB color space)
        function xyzToRGB(X, Y, Z, clamp = true) {
            // Normalize XYZ
            const x = X / 100;
            const y = Y / 100;
            const z = Z / 100;

            // Convert to linear RGB
            let r_linear = x *  3.2406 + y * -1.5372 + z * -0.4986;
            let g_linear = x * -0.9689 + y *  1.8758 + z *  0.0415;
            let b_linear = x *  0.0557 + y * -0.2040 + z *  1.0570;

            // Apply gamma correction (handle negative values properly)
            const gamma = (c) => {
                if (c < 0) {
                    // Negative values can't be gamma corrected normally
                    return -1.055 * Math.pow(-c, 1/2.4) + 0.055;
                } else if (c > 0.0031308) {
                    return 1.055 * Math.pow(c, 1/2.4) - 0.055;
                } else {
                    return 12.92 * c;
                }
            };

            let r = gamma(r_linear);
            let g = gamma(g_linear);
            let b = gamma(b_linear);

            // Check if out of gamut BEFORE clamping
            const outOfGamut = r < 0 || r > 1 || g < 0 || g > 1 || b < 0 || b > 1;

            if (clamp) {
                // Clamp and convert to 0-255 range
                r = Math.max(0, Math.min(1, r)) * 255;
                g = Math.max(0, Math.min(1, g)) * 255;
                b = Math.max(0, Math.min(1, b)) * 255;

                return {
                    r: Math.round(r),
                    g: Math.round(g),
                    b: Math.round(b),
                    outOfGamut
                };
            } else {
                // Return unclamped values for dithering
                return {
                    r: r * 255,
                    g: g * 255,
                    b: b * 255,
                    outOfGamut
                };
            }
        }

        // Convert LAB to RGB
        function labToRGB(L, a, b) {
            const xyz = labToXYZ(L, a, b);
            return xyzToRGB(xyz.X, xyz.Y, xyz.Z);
        }

        // RGB to Hex conversion
        function rgbToHex(r, g, b) {
            const toHex = (n) => {
                const hex = n.toString(16);
                return hex.length === 1 ? '0' + hex : hex;
            };
            return '#' + toHex(r) + toHex(g) + toHex(b);
        }

        // RGB to HSV conversion
        function rgbToHSV(r, g, b) {
            r /= 255;
            g /= 255;
            b /= 255;

            const max = Math.max(r, g, b);
            const min = Math.min(r, g, b);
            const delta = max - min;

            let h = 0;
            if (delta !== 0) {
                if (max === r) {
                    h = ((g - b) / delta) % 6;
                } else if (max === g) {
                    h = (b - r) / delta + 2;
                } else {
                    h = (r - g) / delta + 4;
                }
                h = Math.round(h * 60);
                if (h < 0) h += 360;
            }

            const s = max === 0 ? 0 : Math.round((delta / max) * 100);
            const v = Math.round(max * 100);

            return { h, s, v };
        }

        // Dithering functions for out-of-gamut colors and sub-pixel accuracy
        function shouldDither(rgb) {
            // Dither if out of gamut
            if (rgb.outOfGamut) return true;

            // Dither if we have significant fractional components (sub-pixel accuracy)
            // Check if any channel has meaningful fractional part (> 0.1 difference from rounded)
            const rFrac = Math.abs(rgb.r - Math.round(rgb.r));
            const gFrac = Math.abs(rgb.g - Math.round(rgb.g));
            const bFrac = Math.abs(rgb.b - Math.round(rgb.b));

            // Use dithering if any channel has > 0.15 fractional component
            // (This threshold avoids dithering for tiny imperceptible differences)
            return rFrac > 0.15 || gFrac > 0.15 || bFrac > 0.15;
        }

        function createDitheredSwatch(lab, size = 24) {
            const canvas = document.createElement('canvas');
            canvas.width = canvas.height = size;
            canvas.className = 'color-swatch';
            canvas.style.display = 'inline-block';
            canvas.style.verticalAlign = 'middle';
            canvas.style.marginRight = '8px';

            // Get unclamped RGB values
            const xyz = labToXYZ(lab.L, lab.a, lab.b);
            const targetRGB = xyzToRGB(xyz.X, xyz.Y, xyz.Z, false);

            // Set tooltip based on reason for dithering
            if (targetRGB.outOfGamut) {
                canvas.title = 'Dithered: This color is outside the sRGB gamut';
            } else {
                canvas.title = 'Dithered: Sub-pixel accuracy for precise color representation';
            }

            const ctx = canvas.getContext('2d');
            const imageData = ctx.createImageData(size, size);

            // Create error diffusion buffer (Floyd-Steinberg dithering)
            const errors = Array(size).fill(null).map(() =>
                Array(size).fill(null).map(() => ({ r: 0, g: 0, b: 0 }))
            );

            for (let y = 0; y < size; y++) {
                for (let x = 0; x < size; x++) {
                    const idx = (y * size + x) * 4;

                    // Add accumulated error to target color
                    let r = targetRGB.r + errors[y][x].r;
                    let g = targetRGB.g + errors[y][x].g;
                    let b = targetRGB.b + errors[y][x].b;

                    // Clamp to valid range
                    const newR = Math.max(0, Math.min(255, Math.round(r)));
                    const newG = Math.max(0, Math.min(255, Math.round(g)));
                    const newB = Math.max(0, Math.min(255, Math.round(b)));

                    // Set pixel
                    imageData.data[idx] = newR;
                    imageData.data[idx + 1] = newG;
                    imageData.data[idx + 2] = newB;
                    imageData.data[idx + 3] = 255; // Alpha

                    // Calculate quantization error
                    const errR = r - newR;
                    const errG = g - newG;
                    const errB = b - newB;

                    // Distribute error to neighboring pixels (Floyd-Steinberg)
                    if (x + 1 < size) {
                        errors[y][x + 1].r += errR * 7/16;
                        errors[y][x + 1].g += errG * 7/16;
                        errors[y][x + 1].b += errB * 7/16;
                    }
                    if (y + 1 < size) {
                        if (x > 0) {
                            errors[y + 1][x - 1].r += errR * 3/16;
                            errors[y + 1][x - 1].g += errG * 3/16;
                            errors[y + 1][x - 1].b += errB * 3/16;
                        }
                        errors[y + 1][x].r += errR * 5/16;
                        errors[y + 1][x].g += errG * 5/16;
                        errors[y + 1][x].b += errB * 5/16;
                        if (x + 1 < size) {
                            errors[y + 1][x + 1].r += errR * 1/16;
                            errors[y + 1][x + 1].g += errG * 1/16;
                            errors[y + 1][x + 1].b += errB * 1/16;
                        }
                    }
                }
            }

            ctx.putImageData(imageData, 0, 0);
            return canvas;
        }

        // Update color cells based on current mode
        function updateColorCells() {
            const rows = document.querySelectorAll('#filamentTable tbody tr');
            let ditheredCount = 0;

            rows.forEach(row => {
                const colorCell = row.querySelector('.color-cell');
                const labStr = row.dataset.lab;
                const lab = parseLAB(labStr);

                // Calculate RGB from LAB and check if out of gamut
                const rgb = labToRGB(lab.L, lab.a, lab.b);
                const hex = rgbToHex(rgb.r, rgb.g, rgb.b);

                let displayText = '';
                let swatchColor = hex;

                switch (currentColorMode) {
                    case 'lab':
                        displayText = labStr;
                        break;
                    case 'rgb':
                        displayText = `${rgb.r}, ${rgb.g}, ${rgb.b}`;
                        break;
                    case 'hsv':
                        const hsv = rgbToHSV(rgb.r, rgb.g, rgb.b);
                        displayText = `${hsv.h}Â°, ${hsv.s}%, ${hsv.v}%`;
                        break;
                    case 'hex':
                        displayText = hex.toUpperCase();
                        break;
                }

                // Clear the cell first
                colorCell.innerHTML = '';

                // Get unclamped RGB for dithering decision
                const xyz = labToXYZ(lab.L, lab.a, lab.b);
                const unclampedRGB = xyzToRGB(xyz.X, xyz.Y, xyz.Z, false);

                // Use dithered canvas if we should dither (out of gamut OR sub-pixel accuracy)
                if (shouldDither(unclampedRGB)) {
                    ditheredCount++;
                    const brandName = row.cells[0].textContent.trim();
                    const reason = unclampedRGB.outOfGamut ? 'out-of-gamut' : 'sub-pixel';
                    // console.log(`ðŸŽ¨ Dithering (${reason}): ${brandName} - LAB(${labStr}) - RGB(${unclampedRGB.r.toFixed(2)}, ${unclampedRGB.g.toFixed(2)}, ${unclampedRGB.b.toFixed(2)})`);

                    const canvas = createDitheredSwatch(lab);
                    colorCell.appendChild(canvas);

                    // Add a subtle indicator that dithering is active
                    const indicator = document.createElement('span');
                    // indicator.textContent = 'â—ˆ ';
                    indicator.style.opacity = '0.4';
                    indicator.style.fontSize = '0.8em';
                    indicator.title = unclampedRGB.outOfGamut
                        ? 'Dithered swatch (out of gamut)'
                        : 'Dithered swatch (sub-pixel accuracy)';
                    colorCell.appendChild(indicator);

                    const textNode = document.createTextNode(displayText);
                    colorCell.appendChild(textNode);
                } else {
                    colorCell.innerHTML = `<span class="color-swatch" style="background-color:${swatchColor}"></span>${displayText}`;
                }
            });

            // if (ditheredCount > 0) {
                // console.log(`âœ¨ Total dithered swatches: ${ditheredCount} / ${rows.length}`);
            // }
        }        // Sorting function
        function sortTable(column) {
            const table = document.getElementById('filamentTable');
            const tbody = table.querySelector('tbody');
            const rows = Array.from(tbody.querySelectorAll('tr'));

            // Determine sort direction
            if (currentSort.column === column) {
                currentSort.direction = currentSort.direction === 'asc' ? 'desc' : 'asc';
            } else {
                currentSort.column = column;
                currentSort.direction = 'asc';
            }

            rows.sort((a, b) => {
                let aValue, bValue;

                if (column === 'brand') {
                    aValue = a.cells[0].textContent.trim();
                    bValue = b.cells[0].textContent.trim();
                    return currentSort.direction === 'asc'
                        ? aValue.localeCompare(bValue)
                        : bValue.localeCompare(aValue);
                } else if (column === 'polymer') {
                    aValue = a.cells[1].textContent.trim();
                    bValue = b.cells[1].textContent.trim();
                    return currentSort.direction === 'asc'
                        ? aValue.localeCompare(bValue)
                        : bValue.localeCompare(aValue);
                } else if (column === 'color') {
                    // Sort by LAB lightness (first value)
                    const aLab = parseLAB(a.dataset.lab);
                    const bLab = parseLAB(b.dataset.lab);

                    // Clear all sort button active states first
                    document.querySelectorAll('.color-mode-btn[data-sort]').forEach(b => b.classList.remove('active'));

                    // Sync with lightness button state
                    sortStates.lightness = currentSort.direction;
                    const lightnessBtn = document.querySelector('.color-mode-btn[data-sort="lightness"]');
                    if (lightnessBtn) {
                        updateSortButtonText(lightnessBtn, 'lightness');
                        lightnessBtn.classList.add('active');
                    }

                    return currentSort.direction === 'asc'
                        ? aLab.L - bLab.L
                        : bLab.L - aLab.L;
                } else if (column === 'date') {
                    // Sort by date using data-date attribute (YYYYMMDD format)
                    const aDateCell = a.cells[3];
                    const bDateCell = b.cells[3];
                    aValue = parseInt(aDateCell.dataset.date || '0');
                    bValue = parseInt(bDateCell.dataset.date || '0');
                    return currentSort.direction === 'asc'
                        ? aValue - bValue
                        : bValue - aValue;
                } else if (column === 'cost') {
                    // Sort by cost (numeric)
                    aValue = parseFloat(a.cells[3].textContent.trim());
                    bValue = parseFloat(b.cells[3].textContent.trim());
                    return currentSort.direction === 'asc'
                        ? aValue - bValue
                        : bValue - aValue;
                }
            });

            // Re-append rows in sorted order
            rows.forEach(row => tbody.appendChild(row));

            // Update header indicators
            updateSortIndicators(column);

            // Clear other sort button active states when clicking column headers
            if (column !== 'color') {
                document.querySelectorAll('.color-mode-btn[data-sort]').forEach(b => b.classList.remove('active'));
            }
        }

        function updateSortIndicators(activeColumn) {
            const headers = document.querySelectorAll('th[data-sort]');
            headers.forEach(th => {
                th.classList.remove('sorted-asc', 'sorted-desc');
                if (th.dataset.sort === activeColumn) {
                    th.classList.add(currentSort.direction === 'asc' ? 'sorted-asc' : 'sorted-desc');
                }
            });
        }

        // Event listeners
        document.querySelectorAll('.color-mode-btn[data-mode]').forEach(btn => {
            btn.addEventListener('click', () => {
                // Update active button (only for color format buttons)
                document.querySelectorAll('.color-mode-btn[data-mode]').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');

                // Update color mode
                currentColorMode = btn.dataset.mode;
                updateColorCells();
            });
        });

        document.querySelectorAll('th[data-sort]').forEach(th => {
            th.addEventListener('click', () => {
                sortTable(th.dataset.sort);
            });
        });


        // Track sort state for toggle buttons
        let sortStates = {
            lightness: 'desc',  // Start with high to low (â†“)
            warmth: 'asc',      // Start with cool to warm (â†‘)
            strength: 'asc'     // Start with least to most (â†‘)
        };

        // Tint sort buttons
        document.querySelectorAll('.color-mode-btn[data-sort]').forEach(btn => {
            btn.addEventListener('click', () => {
                const sortType = btn.dataset.sort;

                // Toggle the direction
                sortStates[sortType] = sortStates[sortType] === 'asc' ? 'desc' : 'asc';

                // Update button text
                updateSortButtonText(btn, sortType);

                // Remove active state from all sort buttons first
                document.querySelectorAll('.color-mode-btn[data-sort]').forEach(b => b.classList.remove('active'));
                // Add active state to clicked button
                btn.classList.add('active');

                // Perform sort
                sortByAttribute(sortType, sortStates[sortType]);
            });
        });

        function updateSortButtonText(btn, sortType) {
            const direction = sortStates[sortType];

            if (sortType === 'lightness') {
                btn.textContent = direction === 'desc' ? 'Lightness â†“' : 'Lightness â†‘';
            } else if (sortType === 'warmth') {
                btn.textContent = direction === 'asc' ? 'Tint Warmth â†‘' : 'Tint Warmth â†“';
            } else if (sortType === 'strength') {
                btn.textContent = direction === 'asc' ? 'Tint Strength â†‘' : 'Tint Strength â†“';
            }
        }

        // Sort by attribute
        function sortByAttribute(sortType, direction) {
            const table = document.getElementById('filamentTable');
            const tbody = table.querySelector('tbody');
            const rows = Array.from(tbody.querySelectorAll('tr'));

            rows.sort((a, b) => {
                const aLab = parseLAB(a.dataset.lab);
                const bLab = parseLAB(b.dataset.lab);

                let comparison = 0;

                if (sortType === 'lightness') {
                    // Sort by L value (lightness)
                    comparison = aLab.L - bLab.L;
                } else if (sortType === 'warmth') {
                    // Sort by b value (blue-yellow axis)
                    comparison = aLab.b - bLab.b;
                } else if (sortType === 'strength') {
                    // Sort by tint intensity (chroma/saturation)
                    const aChroma = Math.sqrt(aLab.a * aLab.a + aLab.b * aLab.b);
                    const bChroma = Math.sqrt(bLab.a * bLab.a + bLab.b * bLab.b);
                    comparison = aChroma - bChroma;
                }

                return direction === 'asc' ? comparison : -comparison;
            });

            // Re-append rows in sorted order
            rows.forEach(row => tbody.appendChild(row));

            // Update Color column header indicator when using attribute sorts
            const headers = document.querySelectorAll('th[data-sort]');
            headers.forEach(th => th.classList.remove('sorted-asc', 'sorted-desc'));

            const colorHeader = document.querySelector('th[data-sort="color"]');
            if (colorHeader) {
                colorHeader.classList.add(direction === 'asc' ? 'sorted-asc' : 'sorted-desc');
            }

            // Update current sort state to match
            currentSort = { column: 'color', direction: direction };
        }

        // Hover effect for color comparison
        function setupColorComparisonHover() {
            const rows = document.querySelectorAll('#filamentTable tbody tr');
            const allColorCells = document.querySelectorAll('.color-cell');
            let currentlyActiveRow = null;

            function applyColorBackground(row) {
                const labStr = row.dataset.lab;
                if (!labStr) return;

                const lab = parseLAB(labStr);
                const rgb = labToRGB(lab.L, lab.a, lab.b);
                const hex = rgbToHex(rgb.r, rgb.g, rgb.b);

                // Apply the color as background to all color cells
                allColorCells.forEach(cell => {
                    cell.style.backgroundColor = hex;
                    cell.style.color = '#000000'; // Black text for visibility on light backgrounds
                });

                // Also paint the entire hovered/tapped row with its color
                Array.from(row.cells).forEach(cell => {
                    cell.style.backgroundColor = hex;
                    cell.style.color = '#000000'; // Black text for visibility
                });
            }

            function clearColorBackground() {
                // Clear backgrounds on all color cells
                allColorCells.forEach(cell => {
                    cell.style.backgroundColor = '';
                    cell.style.color = ''; // Reset to default text color
                });

                // Clear all row backgrounds
                rows.forEach(row => {
                    Array.from(row.cells).forEach(cell => {
                        cell.style.backgroundColor = '';
                        cell.style.color = '';
                    });
                });

                currentlyActiveRow = null;
            }            rows.forEach(row => {
                // Mouse events (desktop)
                row.addEventListener('mouseenter', function() {
                    applyColorBackground(this);
                });

                row.addEventListener('mouseleave', function() {
                    clearColorBackground();
                });

                // Touch events (mobile/tablet)
                row.addEventListener('touchstart', function(e) {
                    // If tapping the same row, toggle off
                    if (currentlyActiveRow === this) {
                        clearColorBackground();
                    } else {
                        // Clear previous selection first
                        clearColorBackground();
                        // Then apply new color
                        currentlyActiveRow = this;
                        applyColorBackground(this);
                    }
                    // Don't prevent default - allow scrolling and other interactions
                }, { passive: true });
            });

            // Clear on tap outside the table
            document.addEventListener('touchstart', function(e) {
                const table = document.getElementById('filamentTable');
                if (table && !table.contains(e.target) && currentlyActiveRow) {
                    clearColorBackground();
                }
            }, { passive: true });
        }

        // Initialize
        updateColorCells();
        setupColorComparisonHover();

        // Set initial sort state to reflect natural descending brightness order
        currentSort = { column: 'color', direction: 'desc' };
        const colorHeader = document.querySelector('th[data-sort="color"]');
        if (colorHeader) {
            colorHeader.classList.add('sorted-desc');
        }
        const lightnessBtn = document.querySelector('.color-mode-btn[data-sort="lightness"]');
        if (lightnessBtn) {
            lightnessBtn.classList.add('active');
        }

        // Diagnostic: Check all colors for gamut issues
        // console.log('=== GAMUT DIAGNOSTIC ===');
        document.querySelectorAll('#filamentTable tbody tr').forEach(row => {
            const labStr = row.dataset.lab;
            if (!labStr) return;

            const lab = parseLAB(labStr);
            const xyz = labToXYZ(lab.L, lab.a, lab.b);

            // Check linear RGB before gamma correction
            const x = xyz.X / 100;
            const y = xyz.Y / 100;
            const z = xyz.Z / 100;
            const r_linear = x *  3.2406 + y * -1.5372 + z * -0.4986;
            const g_linear = x * -0.9689 + y *  1.8758 + z *  0.0415;
            const b_linear = x *  0.0557 + y * -0.2040 + z *  1.0570;

            const rgb = xyzToRGB(xyz.X, xyz.Y, xyz.Z, false);

            const brandName = row.cells[0].textContent.trim();
            const linear = `R:${r_linear.toFixed(4)} G:${g_linear.toFixed(4)} B:${b_linear.toFixed(4)}`;
            const gammaCorrected = `R:${(rgb.r/255).toFixed(4)} G:${(rgb.g/255).toFixed(4)} B:${(rgb.b/255).toFixed(4)}`;

            // if (r_linear < 0 || g_linear < 0 || b_linear < 0 || rgb.outOfGamut) {
            //     console.log(`âš ï¸ OUT OF GAMUT: ${brandName}`);
            //     console.log(`   LAB: ${labStr}`);
            //     console.log(`   Linear RGB: ${linear}`);
            //     console.log(`   Gamma-corrected: ${gammaCorrected}`);
            //     console.log(`   Flag: ${rgb.outOfGamut}`);
            // }
        });
    </script>
</body>
</html>
